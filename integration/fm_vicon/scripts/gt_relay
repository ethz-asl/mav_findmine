#!/usr/bin/env python
# -*- coding: utf-8 -*-

# MIT License
#
# Copyright (c) 2020 Rik Baehnemann, ASL, ETH Zurich, Switzerland
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import rospy
import tf

import tf2_ros
import geometry_msgs.msg
import nav_msgs.msg

import tf.transformations as tr

from geometry_msgs.msg import Point
from geometry_msgs.msg import Pose
from geometry_msgs.msg import PoseStamped
from geometry_msgs.msg import Quaternion
from geometry_msgs.msg import Transform
from geometry_msgs.msg import TransformStamped
from geometry_msgs.msg import Vector3

import numpy as np

def pose_to_pq(msg):
    """Convert a C{geometry_msgs/Pose} into position/quaternion np arrays

    @param msg: ROS message to be converted
    @return:
      - p: position as a np.array
      - q: quaternion as a numpy array (order = [x,y,z,w])
    """
    p = np.array([msg.position.x, msg.position.y, msg.position.z])
    q = np.array([msg.orientation.x, msg.orientation.y,
                  msg.orientation.z, msg.orientation.w])
    return p, q


def pose_stamped_to_pq(msg):
    """Convert a C{geometry_msgs/PoseStamped} into position/quaternion np arrays

    @param msg: ROS message to be converted
    @return:
      - p: position as a np.array
      - q: quaternion as a numpy array (order = [x,y,z,w])
    """
    return pose_to_pq(msg.pose)


def transform_to_pq(msg):
    """Convert a C{geometry_msgs/Transform} into position/quaternion np arrays

    @param msg: ROS message to be converted
    @return:
      - p: position as a np.array
      - q: quaternion as a numpy array (order = [x,y,z,w])
    """
    p = np.array([msg.translation.x, msg.translation.y, msg.translation.z])
    q = np.array([msg.rotation.x, msg.rotation.y,
                  msg.rotation.z, msg.rotation.w])
    return p, q


def transform_stamped_to_pq(msg):
    """Convert a C{geometry_msgs/TransformStamped} into position/quaternion np arrays

    @param msg: ROS message to be converted
    @return:
      - p: position as a np.array
      - q: quaternion as a numpy array (order = [x,y,z,w])
    """
    return transform_to_pq(msg.transform)


def msg_to_se3(msg):
    """Conversion from geometric ROS messages into SE(3)

    @param msg: Message to transform. Acceptable types - C{geometry_msgs/Pose}, C{geometry_msgs/PoseStamped},
    C{geometry_msgs/Transform}, or C{geometry_msgs/TransformStamped}
    @return: a 4x4 SE(3) matrix as a numpy array
    @note: Throws TypeError if we receive an incorrect type.
    """
    if isinstance(msg, Pose):
        p, q = pose_to_pq(msg)
    elif isinstance(msg, PoseStamped):
        p, q = pose_stamped_to_pq(msg)
    elif isinstance(msg, Transform):
        p, q = transform_to_pq(msg)
    elif isinstance(msg, TransformStamped):
        p, q = transform_stamped_to_pq(msg)
    else:
        raise TypeError("Invalid type for conversion to SE(3)")
    norm = np.linalg.norm(q)
    if np.abs(norm - 1.0) > 1e-3:
        raise ValueError(
            "Received un-normalized quaternion (q = {0:s} ||q|| = {1:3.6f})".format(
                str(q), np.linalg.norm(q)))
    elif np.abs(norm - 1.0) > 1e-6:
        q = q / norm
    g = tr.quaternion_matrix(q)
    g[0:3, -1] = p
    return g

def callback(data, args):
    frame_id = 'vicon'

    # Vicon ground truth.
    T_IB_gt = geometry_msgs.msg.Transform()
    try:
        T_IB_gt = args[0].lookup_transform(frame_id, 'adis16448bmlz_vicon', data.header.stamp - args[3])
    except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
        return

    msg_gt = nav_msgs.msg.Odometry()
    msg_gt.header.stamp = data.header.stamp
    msg_gt.header.frame_id = frame_id

    msg_gt.pose.pose.position = geometry_msgs.msg.Point(T_IB_gt.transform.translation.x, T_IB_gt.transform.translation.y, T_IB_gt.transform.translation.z)
    msg_gt.pose.pose.orientation = T_IB_gt.transform.rotation

    T_SB = geometry_msgs.msg.Transform()
    try:
        T_SB = args[0].lookup_transform('adis16448bmlz_vicon', 'moa', data.header.stamp - args[3])
    except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
        return

    # omega_sensor = R_SB * omega_body
    # TODO(rikba): delay not handled.
    omega_body = [data.twist.twist.angular.x, data.twist.twist.angular.y, data.twist.twist.angular.z]
    omega_body.append(0.0)
    q_SB = tr.quaternion_from_matrix(msg_to_se3(T_SB))
    omega_sensor = tr.quaternion_multiply(
                     tr.quaternion_multiply(q_SB, omega_body),
                     tr.quaternion_conjugate(q_SB)
                   )
    msg_gt.twist.twist.angular = geometry_msgs.msg.Vector3(omega_sensor[0], omega_sensor[1], omega_sensor[2])
    args[1].publish(msg_gt)

    # Interpolated state estimation odometry.
    T_IB_est = geometry_msgs.msg.Transform()
    try:
        T_IB_est = args[0].lookup_transform(frame_id, 'adis16448bmlz', data.header.stamp - args[3])
    except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
        return

    msg = nav_msgs.msg.Odometry()
    msg = nav_msgs.msg.Odometry()
    msg.header.stamp = data.header.stamp
    msg.header.frame_id = frame_id

    msg.pose.pose.position = geometry_msgs.msg.Point(T_IB_est.transform.translation.x, T_IB_est.transform.translation.y, T_IB_est.transform.translation.z)
    msg.pose.pose.orientation = T_IB_est.transform.rotation
    args[2].publish(msg)

if __name__ == '__main__':
    rospy.init_node('gt_relay')

    tf_buffer = tf2_ros.Buffer()
    listener = tf2_ros.TransformListener(tf_buffer)
    delay = rospy.get_param('~vicon_delay_s', 0.0)
    vicon_delay_s = rospy.Duration(delay)
    rospy.loginfo("Configured Vicon delay: %.6f s", (delay))
    gt_pub = rospy.Publisher('/moa/mav_state_estimator/gt_odometry', nav_msgs.msg.Odometry, queue_size=1)
    interpolated_pub = rospy.Publisher('/moa/mav_state_estimator/interpolated_odometry', nav_msgs.msg.Odometry, queue_size=1)
    rospy.Subscriber("/moa/vrpn_client/estimated_odometry", nav_msgs.msg.Odometry, callback, (tf_buffer, gt_pub, interpolated_pub, vicon_delay_s))
    rospy.spin()
